# Technical research for Midnight wallet and P2P betting dApp

Midnight is now mature enough to build on. The blockchain launched its federated mainnet (Kūkolu phase) in Q1 2026, with a live testnet, open-source Compact smart contract compiler, a comprehensive TypeScript SDK, and over 100 ecosystem partners deploying privacy dApps. Building a native wallet and a voice-driven betting application on Midnight is feasible today using the testnet, with mainnet deployment realistic by Q3 2026 when full decentralization and cross-chain bridging go live. This report covers every technical dimension needed to write system specifications for both products.

---

## Midnight blockchain: architecture and privacy model

Midnight is Cardano's first partner chain — an independent L1 blockchain built on **Substrate (Polkadot SDK)** using IOG's Cardano PartnerChain Framework. It runs its own consensus, tokenomics, and execution environment while leveraging Cardano's Proof-of-Stake infrastructure for security. Cardano SPOs can produce Midnight blocks and earn NIGHT rewards without affecting their ADA operations.

### Zero-knowledge proof system

Midnight uses **zk-SNARKs via the Halo2 proving framework** (Plonk-derived, developed by Electric Coin Co.). As of the testnet-02 upgrade in May 2025, the network transitioned from Pluto-Eris curves to **BLS12-381** for better proving efficiency and cross-chain interoperability. The system supports recursive proofs through a collaboration with Galois Inc., enabling ZK Rollup-style nesting of proofs across blocks. No trusted setup is required.

The privacy architecture rests on two IOG research protocols. **Kachina** enables users to process private state transitions off-chain and submit only ZK proofs to the public ledger. **Zswap** (based on Zerocash) provides confidential atomic asset swaps using sparse multi-value Pedersen commitments. The critical design principle: **private inputs never leave the user's machine**. A local proof server running in Docker (port 6300) generates ZK proofs client-side; only the proof and public data are submitted on-chain.

### Dual-ledger privacy model

Midnight maintains both an **unshielded (public, transparent) ledger state** and a **shielded (private) state** on the same chain. Smart contracts can operate across both, giving developers fine-grained control over what data is visible. The `disclose()` keyword in Compact explicitly reveals private values to public state — disclosure is always opt-in. This "rational privacy" model lets users prove compliance, identity, or eligibility via ZKPs without revealing underlying data.

### Token model: NIGHT and DUST

**NIGHT** is the native governance/utility token with a fixed supply of **24 billion** (subunit: 1 NIGHT = 1,000,000 STAR). It is non-expendable — never spent on transactions or burned. NIGHT exists natively on both Cardano (as a Cardano Native Asset) and Midnight, with protocol-level mechanisms preventing value duplication: tokens unlocked on one chain are locked on the other. NIGHT launched December 4, 2025, with exchange listings on Kraken, OKX, Bybit, KuCoin, Gate, and MEXC. Distribution happened via "Glacier Drop," a multi-phase airdrop targeting ADA, BTC, ETH, SOL, XRP, BNB, AVAX, and BAT holders — over 4.5 billion tokens distributed to 8+ million wallets.

**DUST** is fundamentally different — a shielded, non-transferable, decaying capacity resource generated by holding NIGHT tokens. Using DUST for transactions hides wallet addresses and transaction metadata. It regenerates over time based on NIGHT holdings, decays if unused (preventing hoarding/spam), and cannot be sent between wallets (though it can be delegated). This is the "gas" equivalent, but it behaves more like a renewable resource than a consumable token. Critically, **dApps can sponsor DUST for users** through third-party gateways (Babel Station), meaning end users don't need to hold NIGHT at all.

For testnet development, **tDUST** is available free from the official faucet at midnight.network/test-faucet.

### Cardano bridge and interoperability

The Midnight-Cardano connection operates through several mechanisms. NIGHT tokens maintain native existence on both chains with protocol-enforced mutual exclusivity. **Wanchain** is developing a decentralized cross-chain bridge with a novel ZKP relayer (funded via Project Catalyst Fund 13). IOG built an open-source **Halo2-Plutus Verifier** bridging Halo2 proof verification with Plutus smart contracts on Cardano, using recursive proofs verified on-chain. A proposed CIP for MSM (multi-scalar multiplication) over BLS12-381 would optimize verifier performance. Full bridging infrastructure is scheduled for the **Hua phase (Q3 2026)**.

---

## Compact smart contract language: syntax, capabilities, and limitations

Compact (recently open-sourced as **"Minokawa"** under LF Decentralized Trust) is Midnight's statically typed, TypeScript-based domain-specific language for writing ZK smart contracts. The current compiler version is **0.25.0** with language version **0.16**. The compiler converts contracts into executable ZK circuits, outputting TypeScript type definitions, JS contract implementations, ZK circuit representations, proving keys, and verifying keys.

### Three execution contexts

Every Compact contract operates across three contexts. **Ledger** defines public, on-chain state (e.g., `Counter` type for numeric values, `Uint<128>` for amounts). **Circuits** are off-chain logic that generates ZK proofs — exported as callable entry points and compiled to ZK circuits. **Witnesses** hold privately-known data accessible only to the executing entity, with implementations provided in TypeScript.

### Real Compact code example

A bulletin board contract with ZK identity protection demonstrates the language's approach to privacy:

```compact
pragma language_version 0.16;
import CompactStandardLibrary;

enum State { UNSET, SET }

export ledger authority: Bytes<32>;
export ledger value: Uint<64>;
export ledger state: State;
export ledger round: Counter;

constructor(sk: Bytes<32>, v: Uint<64>) {
  authority = disclose(publicKey(round, sk));
  value = disclose(v);
  state = State.SET;
}

circuit publicKey(round: Field, sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<3, Bytes<32>>>(
    [pad(32, "midnight:examples:lock:pk"), round as Bytes<32>, sk]);
}

witness secretKey(): Bytes<32>;

export circuit set(v: Uint<64>): [] {
  assert(state == State.UNSET, "Attempted to set initialized value");
  const sk = secretKey();
  authority = disclose(publicKey(round, sk));
  value = disclose(v);
  state = State.SET;
}
```

The `disclose()` keyword marks the critical boundary between private and public state. The `witness` function retrieves data known only locally. The `circuit` functions compile to ZK circuits that prove correctness without revealing inputs.

### Built-in types and standard library

Compact offers `Uint<N>`, `Bytes<N>`, `Field`, `Boolean`, `Counter`, `Vector`, `Opaque<"string">`, enums, and structs. The `CompactStandardLibrary` provides `transientHash`, `persistentHash`, `transientCommit`, `persistentCommit`, and elliptic curve operations (`ecAdd`, `ecMul`, `ecMulGenerator`, `hashToCurve`). Modules and generics are supported. **OpenZeppelin has released experimental Compact contracts** including FungibleToken (ERC-20 equivalent), NonFungibleToken (ERC-721 approximation), Ownable, Pausable, and AccessControl modules.

### Current limitations

Compact supports bounded computation only — no unbounded loops. **Cross-contract calls are not yet implemented** (the `contract` keyword is reserved). The Compact compiler cannot be compiled independently yet; some dependencies are still being open-sourced. There is no access to transaction sender identity or amounts by design (privacy-first). Development is supported on Linux, macOS, and Windows (WSL only).

### Implications for a betting contract

A betting/escrow contract in Compact would define ledger state for bet terms (amount, deadline, conditions, party commitments) as public or private fields depending on desired visibility. The resolution logic would live in circuit functions that verify both parties' agreement on outcomes through ZK proofs. The witness functions would provide private inputs like party identities and secret keys. The `disclose()` mechanism would selectively reveal only what's necessary for settlement — potentially just the outcome and payout amounts, not the parties' identities.

---

## Developer tools, SDK, and current ecosystem

### GitHub repositories

The official GitHub organization is **github.com/midnightntwrk** with 26 public repositories. Core infrastructure includes:

- **midnight-node** (Rust): Substrate-based blockchain node with 6 custom runtime pallets
- **midnight-zk** (Rust): Zero-knowledge proving system (36 stars)
- **midnight-js** (TypeScript): Client library for DApp development (24 stars)
- **midnight-indexer** (Rust): Blockchain indexer with GraphQL API supporting PostgreSQL and SQLite
- **midnight-docs**: Official documentation built with Docusaurus/MDX

Official example dApps include **example-counter** (counter contract + CLI starter template), **example-bboard** (bulletin board with React UI), and **midnight-dapp-connector-api** (wallet-DApp interaction).

Community repositories are growing rapidly. **MeshJS/midnight** provides a monorepo with starter templates, CLI scaffold tool, React hooks, core API, and wallet integration. **OpenZeppelin/midnight-apps** offers standard Compact contracts plus a LunarSwap DEX proof-of-concept. **bricktowers/midnight-local-network** enables running a full local Midnight network via Docker without testnet dependency. **Olanetsoft/compact-by-example** provides a "Solidity by Example"-style tutorial site for Compact.

### npm packages under @midnight-ntwrk

The SDK is comprehensive and TypeScript-first:

**Core packages**: `@midnight-ntwrk/compact-runtime` (v0.9.0) provides runtime primitives for Compact's TypeScript output. `@midnight-ntwrk/midnight-js-contracts` (v3.0.0-alpha.6) handles deployed contract interaction. `@midnight-ntwrk/midnight-js-types` (v2.0.2) provides shared data types.

**Wallet SDK packages**: `@midnight-ntwrk/wallet` (v5.0.0) is the full wallet SDK for key management, transactions, and DApp interaction. `@midnight-ntwrk/wallet-sdk-hd` (v2.0.0) provides HD wallet support with BIP-32/BIP-44/CIP-1852 derivation. `@midnight-ntwrk/wallet-sdk-bech32m` (v2.0.0) handles the new address format.

**DApp integration packages**: `@midnight-ntwrk/dapp-connector-api` (v3.0.0) declares `window.midnight.{walletName}` for wallet-DApp communication. `@midnight-ntwrk/midnight-js-zk-keys` (v2.1.0) handles proving/verifying key retrieval. `@midnight-ntwrk/midnight-js-proof-server` (v2.1.0) interfaces with the local proof server.

HD wallet creation follows familiar patterns:
```typescript
import { generateRandomSeed, HDWallet, Roles } from '@midnight-ntwrk/wallet-sdk-hd';
const seed = generateRandomSeed();
const wallet = HDWallet.fromSeed(seed);
if (wallet.type === 'seedOk') {
  const zswapKey = wallet.hdWallet.selectAccount(0)
    .selectRole(Roles.Zswap).deriveKeyAt(0);
}
```

### Network endpoints and API

Testnet-02 is live with these endpoints: RPC via WebSocket at `wss://rpc.testnet-02.midnight.network` (Substrate-compatible, works with @polkadot/api), Ankr RPC at `https://rpc.ankr.com/midnight_testnet/`, and local indexer GraphQL at `http://127.0.0.1:8088/api/v1/graphql`. The proof server runs locally in Docker on port 6300. The indexer exposes queries, mutations, and real-time subscriptions via GraphQL.

### Developer tooling

The Compact compiler installs via a shell script and supports `compile`, `update`, `list`, and `check` commands. A VS Code extension (v0.2.13) provides syntax highlighting, live semantic analysis, type checking, code completion, and error diagnostics for Compact-specific constructs. Project scaffolding is available through `npx create-mn-app my-app` (official) and `npx create-midnight-app` (community). The Lace browser extension wallet (v3.0.0) is available for testnet development.

### What developers can do today versus what's coming

**Available now**: Write and compile Compact contracts, deploy to testnet-02, build full-stack TypeScript/React dApps with MidnightJS, run local Midnight networks via Docker, use the Lace wallet extension for testing, generate ZK proofs locally, and scaffold projects. **Not yet available**: Mainnet deployment (federated mainnet just launched), cross-contract calls in Compact, independent node compilation, full DUST/cNIGHT infrastructure, and browser-based dApps on testnet-02 (Node.js dApps work; browser issue being resolved).

---

## Wallet architecture: address format and key management

Midnight adopted **Bech32m encoding** for addresses, replacing hexadecimal. Addresses are human-readable, include error detection, and carry metadata (network type, address type). Testnet addresses use the prefix `mn_shield-addr_test1...`. This format is implemented across Wallet SDK 4.0+, Wallet API 4.0+, and DApp Connector API v2.0+.

The key management model separates NIGHT addresses from DUST addresses — a **DUST address is non-derivable from the NIGHT address** that generated it. This architectural separation is essential for privacy: even if a NIGHT address is known publicly, the shielded DUST address used for transactions remains unlinkable. The HD wallet SDK follows BIP-32/BIP-44/CIP-1852 derivation paths with specific roles for Zswap operations.

Announced wallet integrations beyond Lace include SubWallet, NuFi, Vespr, Gero, Tokeo Pay, Keystone, Yoroi, Begin Wallet, and Ctrl Wallet (600K+ users). A new wallet entering this space would compete with these announced integrations but could differentiate through superior UX, seedless architecture, and native betting functionality.

---

## Lessons from Cardano wallets: what to replicate and what to surpass

### Lace (by IOG)

Lace is the reference wallet, built as an open-source Chrome extension (Apache 2.0, github.com/input-output-hk/lace). It uses a monorepo architecture with Blockfrost API as backend, Node.js/yarn build system, and already has a v2 platform (`lace-platform`) with Midnight Preview integration. Key features include multi-delegation staking, transaction bundling (multiple assets to different addresses in one tx, one fee), NFT gallery, CIP-30 dApp connector, Ledger hardware wallet support, and a fiat on-ramp via Banxa. Lace's 18-month roadmap includes Bitcoin support, social sign-in (Google, iCloud), account recovery as a service, and a wallet scripting interface. **Strength to replicate**: IOG-backed, first Midnight support, clean UX. **Weakness to exploit**: No mobile app yet, historically felt too basic, Cardano-only expanding slowly.

### Eternl (by Tastenkunst GmbH)

The most feature-rich Cardano wallet, available as browser extension, PWA, and mobile apps. Its standout capability is **smart UTXO management** that automatically optimizes transactions to reduce fees. It pioneered the first mobile dApp wallet on Cardano with a built-in DApp browser and was the earliest Cardano wallet to implement WalletConnect. Supports up to 24 accounts from one mnemonic, multi-pool delegation, and comprehensive governance features. **Strength to replicate**: UTXO optimization, mobile DApp browser, power-user features. **Weakness to exploit**: Intimidating UI for beginners, steep learning curve.

### Typhon (by Strica)

Notable for its unique **Warp Transactions** feature that uses the receiver's UTXOs to cover minimum ADA requirements for token transfers through Cardano's native multi-signature capability. Typhon's custom dApp API goes beyond CIP-30 by abstracting away UTXO selection, change calculation, fee calculation, and script integrity hash computation. **Strength to replicate**: Developer-friendly high-level API, clean balance of features and simplicity. **Weakness to exploit**: No mobile app, no Firefox version, closed-source.

### Nami (deprecated — merged into Lace)

Nami's deprecation in January 2025 (coinciding with the Plomin hard fork) offers a cautionary tale: simple single-address wallets that can't support governance features become obsolete. Lace absorbed Nami users through a "Nami Mode" migration using Chrome's cross-extension messaging API. **Lesson**: Build governance support from day one.

### What a superior Midnight wallet must address

A best-in-class wallet needs to solve privacy-first ZK proof generation (via local proof server), unified Cardano-Midnight bridging with privacy controls, invisible UTXO management (following Eternl's lead), mobile-first design with DApp browser, a dApp connector API that goes beyond CIP-30's browser-injection model (supporting WalletConnect, WebRTC/CIP-45, and mobile-native connectors), first-class governance integration, and native stablecoin awareness for DJED, USDA, and future Midnight-native tokens.

---

## Stablecoins: current options and Midnight strategy

No stablecoins are deployed natively on Midnight yet. On Cardano, the leading options are **DJED** (algorithmic, over-collateralized with ADA, ~$25.5M TVL, formally verified — the strongest technical candidate), **USDA** (fiat-backed 1:1 USD by Anzens/Encryptus with EMURGO as technology provider, launched early 2025 with $11M TVL in its first month, KYC required for direct minting), **iUSD** (synthetic via Indigo Protocol, first Cardano stablecoin launched November 2022), and **USDM** (USD-backed by Moneta, launched March 2024).

The most relevant development for Midnight is **Private DJED**, announced at Rare Evo 2025 — COTI will bring privacy-enabled DJED to Midnight using ZK proofs, enabling enterprises to operate privately while maintaining regulatory transparency. The total Cardano stablecoin market sits around $38-39 million as of Q3 2025. When the Wanchain bridge completes, assets like ADA and USDC will be able to move between Cardano and Midnight. For the betting app, the strategy should target Private DJED on Midnight as the primary settlement currency, with bridged Cardano stablecoins as fallback.

---

## Recommended technical stack

### Web framework: Next.js 14+ with App Router

Next.js is the clear choice for both products. Midnight's developer tools are TypeScript-first — the Compact compiler outputs TypeScript, MidnightJS is TypeScript, and the Wallet SDK is TypeScript. Coinbase's embedded wallet SDK provides first-class Next.js integration. The framework supports SSR for landing pages while using client components for wallet interactions via the `"use client"` directive. MeshJS/midnight provides React hooks specifically designed for Midnight wallet integration. State management should use **Zustand** for lightweight wallet state (balance, addresses, transaction history) and **TanStack Query** for server state (blockchain queries, price feeds). WebSocket subscriptions handle real-time block confirmations and balance updates — Midnight's ~6-second block time makes this straightforward.

### Voice-to-text: Deepgram Nova-3 for production

For the betting app's voice capture, **real-time streaming is essential** — users dictate bet terms live, making batch-only APIs like Whisper unsuitable. Deepgram Nova-3 offers the best balance: **$0.0043/min batch, $0.0077/min streaming, sub-300ms latency**, and native WebSocket API. AssemblyAI Universal is a strong alternative at $0.0025/min with 300ms P50 latency. OpenAI Whisper ($0.006/min) delivers highest accuracy but lacks native streaming. The Web Speech API provides a zero-cost Chrome/Android fallback but doesn't work in Safari WebView (fatal for iOS PWAs) — it cannot be the sole solution.

The architecture pattern: user taps "Record Bet" → MediaRecorder API captures audio → audio streamed via WebSocket to Deepgram → interim transcripts shown in real-time → final transcript sent to LLM for structured extraction. At an average bet recording of 15 seconds, API cost per bet is roughly **$0.001**.

### AI extraction of bet terms: GPT-4o-mini with structured output

Both OpenAI and Anthropic now support native structured output — the LLM constrains generation to match a JSON schema. GPT-4o-mini at **$0.15/1M input tokens** makes each bet extraction cost approximately **$0.0001**. The pipeline takes transcribed voice like "I bet you $50 the Lakers win tonight" and extracts structured JSON:

```json
{
  "parties": { "proposer": "speaker", "acceptor": "you" },
  "amount": { "value": 50, "currency": "USD" },
  "condition": "Los Angeles Lakers win their game",
  "deadline": "tonight (end of game)",
  "resolution_criteria": "Official NBA game result",
  "confidence": 0.95,
  "ambiguities": ["Specific game not identified"]
}
```

Critical edge cases to handle: ambiguous bets (missing amount, deadline, or resolution criteria), complex conditions with nested clauses, slang normalization ("hundo" → $100), and undefined opponents. Implement a confidence threshold — below 0.7, prompt the user for clarification. Use **Zod + OpenAI structured outputs** in TypeScript for type-safe extraction on the server side.

### Monthly API costs at early scale

At 1,000 active users and 50 bets/day: Deepgram streaming ~$2.50/month, OpenAI GPT-4o-mini ~$1.50/month, Vercel hosting ~$20/month, Web3Auth/Para SDK free tier to $25-99/month. **Total: roughly $50/month** — negligible for a startup.

---

## Authentication: passkeys and MPC replace seed phrases

Passkeys replacing seed phrases is a **proven production pattern**, not theoretical. ZenGo serves millions of users with MPC + biometric recovery and no seed phrase. Coinbase Smart Wallet uses passkey-based onboarding. Clave uses Secure Enclave WebAuthn + smart contract accounts on Ethereum L2. OKX Wallet combines MPC-TSS + Passkey + ERC-4337. Web3Auth and Para provide SDK infrastructure for any wallet to implement this.

### The curve mismatch problem and its solution

WebAuthn passkeys use **P-256 (secp256r1)** while most blockchains use different curves (secp256k1 for Ethereum, Ed25519 for Solana). Passkeys cannot directly sign blockchain transactions. For Midnight, the recommended approach is **MPC + Passkey**: the passkey authorizes a session, and MPC infrastructure generates Midnight-compatible signatures. The passkey unlocks access to a device-bound MPC key share stored in the Secure Enclave; the full signing key is never reconstructed on any single device.

Web3Auth or Para SDK provide the infrastructure layer. Para's architecture: "One share lives on the user's device, secured via passkey or native key storage (e.g., Secure Enclave or Android Keystore). The other is a cloud share encrypted and stored with strict session-based access controls." This creates a non-custodial, seedless wallet experience where the user authenticates with Face ID/Touch ID and the system handles all cryptographic operations invisibly.

Browser/OS support is comprehensive: iOS 16+ (iCloud Keychain sync), Android 9+ (Google Password Manager), macOS Ventura+ (Safari, Chrome), Windows 10+ (Windows Hello), and all major browsers including Firefox.

---

## MPC wallet architecture: deep dive

### How threshold signatures work

In an MPC wallet, the **private key is never created as a whole**. Distributed Key Generation (DKG) creates key shares across multiple parties independently. When signing, each party computes a partial signature using their share; partial signatures combine into one valid signature **indistinguishable from a normal single-key signature** on-chain. Configurable M-of-N thresholds (e.g., 2-of-3) define how many shares must participate.

### ZenGo's proven 2-of-2 architecture

ZenGo uses the simplest production model: a Personal Share on the user's mobile device + a Remote Share on ZenGo's server. Both must cooperate to sign. Neither can sign alone. Recovery uses 3D biometric FaceMap (not just 2D photo) stored encrypted on ZenGo's servers + a recovery file backed up to iCloud/Google Drive. The user never sees or handles any cryptographic material.

### Open-source TSS libraries

- **bnb-chain/tss-lib** (Go): {t,n}-threshold ECDSA via Gennaro-Goldfeder 2018 + EdDSA, audited by Kudelski Security
- **mpc-tss-js** (TypeScript): CGGMP21 UC Non-Interactive TSS — most relevant for a TypeScript-first Midnight stack
- **Fireblocks MPC-CMP**: Open-source reference implementation of their 1-round protocol

For a Midnight wallet, the TypeScript-native **mpc-tss-js** library is the most aligned choice given the SDK ecosystem, though **bnb-chain/tss-lib** is more battle-tested in production.

### MPC advantages over alternatives

MPC generates standard ECDSA/EdDSA signatures that work with any blockchain without on-chain changes. Unlike multi-sig, there's no on-chain exposure of the multi-party structure — it appears as a standard single-key transaction. Key refresh is possible without changing the public key or on-chain address. It's chain-agnostic by design, meaning the same architecture works if the wallet expands to Cardano, Ethereum, or other chains.

---

## Social recovery without seed phrases

### Argent's guardian model

Argent pioneered smart contract wallet social recovery. A single signing key handles daily use, while guardians (friends, family, hardware wallets, or Argent's default guardian) can collectively recover access. Recovery requires majority guardian approval, includes a **48-hour security delay** before completion (preventing unauthorized recovery), and adding/removing guardians takes 36 hours. Daily transfer limits require guardian approval for transactions above the threshold.

### Argent's off-chain recovery (cost-optimized)

To avoid high gas fees, Argent introduced off-chain recovery: the app generates a random Key Encryption Key (KEK), encrypts private keys, stores encrypted keys in the user's iCloud/Google Drive, and sends the KEK to Argent's infrastructure. Recovery retrieves encrypted keys from cloud + verifies identity via 2FA + retrieves KEK from Argent after 48 hours. Non-custodial by design — Argent never simultaneously has both the encrypted keys and the KEK.

### Recommended recovery architecture for the Midnight wallet

Combine MPC with social recovery: the primary authentication uses passkey + MPC 2-of-2 (device share + server share). Recovery path 1: biometric re-authentication on a new device reconstructs the device share from cloud-synced passkeys. Recovery path 2: social/guardian recovery allows trusted contacts to authorize key refresh if passkeys are lost. Recovery path 3: email/phone OTP as last resort, combined with a time-locked security delay. This layered approach eliminates seed phrases entirely while maintaining non-custodial security guarantees.

---

## UX design: making blockchain invisible

### Designing for zero crypto knowledge

Replace all blockchain terminology with familiar language. "Send Bitcoin" becomes "Send Money." "Gas Fee Required" becomes a total fee shown in dollars on a confirmation screen. Show fiat equivalents always — display $50.00 prominently, with "23.45 USDC" as secondary text. Use progressive disclosure: the home screen shows balance + send/receive, with blockchain details hidden behind expandable sections that power users can access.

Leading wallets now score highest on UX when they implement passkey onboarding, gasless flows, chain abstraction, and smart recovery. Coinbase Smart Wallet leads at ~27/30 on industry frameworks, followed by Privy (~26/30) and ZenGo (~25/30). The pattern is clear: **the best wallets feel like fintech apps, not crypto apps**.

### True black (#000000) design considerations

True black delivers maximum OLED battery savings (pixels fully off) and dramatic visual contrast, but creates practical problems: halation (white text bleeds into pure black backgrounds), OLED black smearing during scrolling (pixels can't switch on fast enough), and higher cognitive load during extended sessions. The industry consensus favors **near-black backgrounds (#0F172A or #121212)** — essentially indistinguishable from true black to the human eye while eliminating smearing. Google Material Design uses #121212 as its dark mode default.

The recommended color system for a financial dark theme:

- Background (darkest): **#0F172A** or #121212
- Surface (cards/panels): #1E293B or #1E1E1E
- Elevated (hover/active): #334155
- Text (primary): #F1F5F9
- Text (secondary): #94A3B8
- Accent: desaturated brand color

**Elevation in dark mode works inversely** — lighter surfaces indicate higher elevation, not shadows. Google recommends semi-transparent white overlays: 1dp = 5% white, 4dp = 9% white, 8dp = 12% white. Robinhood's dark mode exemplifies the pattern: minimal 3-4 color palette (signature mint green, red, white/grey on black), extreme minimalism, transparent navigation, rare use of boxes or lines.

### Onboarding flow that hides the wallet

The target flow: enter phone number or email → verify with OTP → create passkey (Face ID/Touch ID prompt) → wallet is created invisibly in background → user sees a balance screen showing $0.00 with a prominent "Add Money" button. No seed phrases, no blockchain terminology, no network selection. The entire wallet creation happens in under 60 seconds. Cash App's approach is the model: Bitcoin is just another tab within a familiar payments interface, users can buy with as little as $1, and there's zero blockchain jargon.

### Fiat on-ramp strategy

No single on-ramp provider covers all regions and payment methods. **MoonPay** (~1% bank, ~4.5% card, 160+ countries) and **Transak** (~1% + network fees, MetaMask's partner) are leading options. **Ramp Network** offers fast KYC across 150+ countries. The recommended approach: embed a white-labeled on-ramp widget styled to match the app's brand, use an aggregator like **Onramper** (15+ on-ramps) for global coverage, and abstract the entire process so the user sees "Add Money" and enters a dollar amount — the system handles conversion to on-chain stablecoins invisibly. Support ACH (cheapest, 1-3 days), debit card (instant, ~3-4.5% fee), and Apple/Google Pay. Show optimistic balance updates immediately even if settlement is asynchronous.

---

## iOS development path

### Phased approach: PWA → Capacitor → React Native

**Phase 1 — PWA**: Next.js PWA with service workers, installable on iOS home screen. Full WebAuthn/passkey support in Safari. Fastest time-to-market with a single codebase. Limitation: no App Store distribution, limited push notifications on iOS.

**Phase 2 — Capacitor native wrapper**: Capacitor wraps the existing Next.js/React web app in a native iOS container, enabling App Store distribution, push notifications, and native plugin access. Critical plugins: `@perfood/capacitor-crypto-api` for Secure Enclave key generation and P-256 ECDSA signing, `@aparajita/capacitor-secure-storage` for iOS Keychain storage, and Ionic Identity Vault for biometric auth + encrypted storage. This achieves **90%+ code reuse** from the web app while gaining native Secure Enclave access.

**Phase 3 — React Native (if needed)**: Only if deep native performance or complex native UI is required. Coinbase successfully runs their production wallet on React Native. Para SDK supports React Native with feature parity.

### App Store approval for crypto wallets

Apple requires developers to be enrolled as an **organization, not individual**. Wallets are permitted under Section 3.1.5(i) but exchanges require appropriate licensing. The rejection rate for crypto wallet apps is approximately **40%**. Key approval strategies: document security architecture thoroughly (Secure Enclave usage, encryption), demonstrate partnerships with recognized blockchain protocols (2.3x higher approval rate), and prepare comprehensive pre-submission documentation (reduces rejection by 73%). Apple's 2025 guideline revision following the Epic Games ruling loosened restrictions on external payment methods and third-party NFT marketplaces.

---

## Network status and development timeline

Midnight follows a four-phase rollout. **Hilo** (completed December 2025): NIGHT token launch on Cardano and exchange listings. **Kūkolu** (current, Q1 2026): Federated mainnet launch with IOG + external enterprises (including a Fortune 500 company) operating nodes, 100+ ecosystem partners deploying privacy dApps. **Mōhalu** (Q2 2026): Incentivized testnet, SPO participation in validation, DUST capacity exchange activation, transition from federated to community-driven block production. **Hua** (Q3 2026): Full decentralization, bridging infrastructure live, hybrid dApps, cross-chain interoperability with Ethereum, Solana, Bitcoin, and XRP.

Current testnet metrics show explosive growth: **1,617% surge in smart contract deployments**, 148% increase in wallet addresses, 261% increase in smart contract calls, and 151% increase in faucet requests through late 2025.

---

## Betting dApp: Compact contract design considerations

A peer-to-peer betting contract on Midnight requires specific architectural decisions. The **ledger state** would store bet terms (hashed for privacy), committed amounts (using Zswap commitments), deadline as a block height or timestamp, and resolution state (pending/resolved/disputed). **Circuit functions** would handle bet creation (both parties prove commitment without revealing identities), bet acceptance (second party proves matching terms), and resolution (both parties submit proofs agreeing on outcome, or a dispute mechanism triggers). **Witness functions** would provide private party identities, bet amounts, and resolution votes.

The privacy properties of Midnight create a unique advantage for betting: **bets can be provably fair without revealing the parties' identities or the bet amounts to the public ledger**. Only the participants (and optionally, a designated arbiter) would know the terms. Settlement would use Zswap's confidential transfer mechanism to move funds to the winner without public visibility of amounts.

For resolution, the simplest pattern is bilateral agreement: both parties submit their view of the outcome as witness data, the circuit verifies agreement, and funds are released. If parties disagree, an escalation mechanism (time-locked arbiter, oracle integration, or community vote) would need to resolve the dispute. Given Compact's current lack of cross-contract calls, the entire betting lifecycle (creation, acceptance, resolution, payout) must be handled within a single contract.

---

## Conclusion

The Midnight ecosystem is substantially more developed than most builders realize. A TypeScript-first SDK, mature Compact compiler, live testnet with Docker-based local development, comprehensive npm packages for wallet and DApp integration, and a clear four-phase mainnet rollout provide a solid foundation for building today. The wallet opportunity is real: announced integrations from SubWallet, Vespr, and others mean competition is coming, but no one has yet built a seedless, MPC-secured, privacy-first Midnight wallet with consumer-grade UX. The recommended stack — Next.js + Midnight SDK + Deepgram + GPT-4o-mini + Passkeys/MPC via Web3Auth or Para + Capacitor for iOS — creates a technically coherent architecture where every component speaks TypeScript and every blockchain complexity can be hidden behind familiar fintech patterns. The betting app benefits uniquely from Midnight's privacy model: provably fair wagers without public visibility of participants or amounts, settled via confidential Zswap transfers, triggered by voice input that AI structures into immutable contract terms.